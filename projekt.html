<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - geometry - terrain</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				color: #61443e;
				font-family:Monospace;
				font-size:13px;
				text-align:center;

				background-color: #bfd1e5;
				margin: 0px;
				overflow: hidden;
			}

			#info {
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
			}

			a {

				color: #a06851;
			}

		</style>
	</head>
	<body>

		<div id="container"><br /><br /><br /><br /><br />Generating world...</div>
		<div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - webgl terrain raycasting demo</div>

		<script src="js/three.min.js"></script>

		<script src="js/OrbitControls.js"></script>
		<script src="http://threejs.org/examples/js/loaders/OBJLoader.js"></script>
		<script src="js/THREEx.KeyboardState.js"></script>
		<script src="js/ImprovedNoise.js"></script>
		<script src="js/LoadingManager.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/Stats.js"></script>
		<script src="js/ImageLoader.js"></script>

		<script>
			
			if ( ! Detector.webgl ) {
		
				Detector.addGetWebGLMessage();
				document.getElementById( 'container' ).innerHTML = "";

			}

			var container, stats;

			var camera, controls, scene, renderer;

			var mesh, texture;

			// širina platna
			var worldWidth = 512, worldDepth = 512,
			worldHalfWidth = worldWidth / 2, worldHalfDepth = worldDepth / 2;

			var clock = new THREE.Clock();
			var keyboard = new THREEx.KeyboardState();

			var helper;


			var hitrost = 0;
			init();
			animate();
			

			function init() {
				
				//definiramo novo sceno
				container = document.getElementById( 'container' );
				scene = new THREE.Scene();
				//deefiniramo novo perspektivno kamero
				camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 40000 );
				scene.add(camera);
				camera.position.set(1000,2000,3000);
				camera.lookAt(scene.position);

				//tukaj kličemo funkcijo ki nam vrne podatke, ki jih uporabimo za generiranje terena
				data = generateHeight( worldWidth, worldDepth );
				//te podatke lahko izpišemo v konzolo
				console.log(data);
				//naredimo novo ravnino katero bomo preoblikovali v nek teren
				var geometry = new THREE.PlaneBufferGeometry( 30000, 30000, worldWidth - 1, worldDepth - 1 );
				//geometrijo rotiramo za -90, ker ima default navpično se mi zdi
				geometry.rotateX( - Math.PI / 2 );
				//to je seznam vseh točk, ki jim bomo spremenili parametre, da dobimo razgibanost
				var vertices = geometry.attributes.position.array;

				for ( var i = 0, j = 0, l = vertices.length; i < l; i ++, j += 3 ) {

					vertices[ j + 1 ] = data[ i ] * 10;

				}

				geometry.computeFaceNormals();

				//nardimo texturo z to funkcijo se nisem preveč ukvarjal, ker mgoč bomo tko dal uno blander varjanto
				texture = new THREE.CanvasTexture( generateTexture( data, worldWidth, worldDepth ) );
				texture.wrapS = THREE.ClampToEdgeWrapping;
				texture.wrapT = THREE.ClampToEdgeWrapping;

				//nardimo nov mesh(objekt) ki mu damo geometrijo od zgoraj in to texturo
				mesh = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { map: texture } ) );
				mesh.castShadow = true;
				scene.add( mesh );

				//TEREN

					// -> HRIBI&DOLINE
				var geometry = new THREE.CylinderGeometry( 0, 20, 100, 3 );
				geometry.translate( 0, 50, 0 );
				geometry.rotateX( Math.PI / 2 );
				helper = new THREE.Mesh( geometry, new THREE.MeshNormalMaterial() );
				scene.add( helper );
					//VODA
				var waterTexture = new THREE.ImageUtils.loadTexture( 'images/water512.jpg' );
				waterTexture.wrapS = waterTexture.wrapT = THREE.RepeatWrapping;
				waterTexture.repeat.set( 10, 10 );
				var waterMaterial = new THREE.MeshBasicMaterial( { map: waterTexture, side: THREE.DoubleSide } );
				var waterGeometry = new THREE.PlaneBufferGeometry( 30000, 30000, worldWidth - 1, worldDepth - 1 );
				var water = new THREE.Mesh(waterGeometry, waterMaterial);
				waterGeometry.rotateX( - Math.PI / 2 );
				water.position.y += 100;
				scene.add(water);

				var ambient = new THREE.AmbientLight( 0x999999 );
				scene.add( ambient );

				//LETALO
				var manager = new THREE.LoadingManager();
				manager.onProgress = function ( item, loaded, total ) {
					console.log( item, loaded, total );
				};

				var planeTexture = new THREE.Texture();

				var onProgress = function ( xhr ) {
					if ( xhr.lengthComputable ) {
						var percentComplete = xhr.loaded / xhr.total * 100;
						console.log( Math.round(percentComplete, 2) + '% downloaded' );
					}
				};
				var onError = function ( xhr ) {
				};
				var loader = new THREE.ImageLoader( manager );
				loader.load( 'mustang/BodyTexture.bmp', function ( image ) {
					planeTexture.image = image;
					planeTexture.needsUpdate = true;
				} );


				var loader = new THREE.OBJLoader( manager );
				loader.load( 'mustang/mustang.obj', function ( object ) {

						object.traverse( function ( child ) {

							if ( child instanceof THREE.Mesh ) {

								child.material.map = planeTexture;

						}
					} );

					object.position.y = 10000;
					object.position.z = 1300;
					object.position.x = 1500;
                    object.scale.x = 0.1;
                    object.scale.y = 0.1;
                    object.scale.z = 0.1;
					
                    MovingCube = object
					scene.add( MovingCube );

				} , onProgress, onError );

    			//KOVANEC
				var coinTexture = new THREE.ImageUtils.loadTexture( 'images/kovanc.png' );
				var coinGeometry = new THREE.CylinderGeometry( 100, 100, 20, 32 );
				var material = new THREE.MeshBasicMaterial( {map: planeTexture} );
				Cylinder = new THREE.Mesh( coinGeometry.clone(), material );
				Cylinder2 = new THREE.Mesh( coinGeometry.clone(), material );
				Cylinder3 = new THREE.Mesh( coinGeometry.clone(), material );
				Cylinder4 = new THREE.Mesh( coinGeometry.clone(), material );
				Cylinder.position.y = 1000;
				Cylinder.rotateX( - Math.PI / 2 );
				scene.add( Cylinder);
				Cylinder2.rotateX( - Math.PI / 2 );
				Cylinder2.position.y = 1000;
				Cylinder2.position.x = 300;
				Cylinder2.position.z = 300;
				scene.add(Cylinder2);


				//SUN

				var sunTexture = new THREE.ImageUtils.loadTexture( 'images/sun.gif' );
				var sunMaterial = new THREE.MeshBasicMaterial( { map: sunTexture, side: THREE.DoubleSide } );

				var sunSphereGeometry = new THREE.SphereGeometry(2000, 128, 128);
				sunSphere = new THREE.Mesh( sunSphereGeometry, sunMaterial);
				sunSphere.position.set(0,0,-14000);
				scene.add(sunSphere);

				//SKY

				var skyTexture = new THREE.ImageUtils.loadTexture( 'images/nebo.png' );
				skyTexture.wrapS = skyTexture.wrapT = THREE.RepeatWrapping;
				skyTexture.repeat.set( 10, 10 );

				var skyMaterial = new THREE.MeshBasicMaterial( { map: skyTexture, side: THREE.DoubleSide } );
				var a = new THREE.Vector3( 0, 0, 0 );

				var skySphereGeometry = new THREE.SphereGeometry(20000, 128, 128);
				var skySphere = new THREE.Mesh( skySphereGeometry, skyMaterial);
				scene.add(skySphere);


				renderer = new THREE.WebGLRenderer();
				renderer.setClearColor( 0xbfd1e5 );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );

				container.innerHTML = "";

				container.appendChild( renderer.domElement );

				renderer.shadowMapEnabled = true;
	
				// "shadow cameras" show the light source and direction
	
				// spotlight #1 -- yellow, dark shadow
				spotlight = new THREE.SpotLight(0xffff00);
				spotlight.position.set(0,0,-14000);
				spotlight.shadowCameraVisible = true;
				spotlight.shadowDarkness = 0.95;
				spotlight.intensity = 2;
				// must enable shadow casting ability for the light
				spotlight.castShadow = true;
				scene.add(spotlight);
				
				
				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				//

				window.addEventListener( 'resize', onWindowResize, false );

			}

			var MovingCube;
			var Cylinder, Cylinder2, sunSphere;
			var spotlight;
			

			function update(){				
				
				var rotateAngle = Math.PI / 100 ;
				Cylinder.rotateOnAxis( new THREE.Vector3(0,0,1), rotateAngle);
				Cylinder2.rotateOnAxis( new THREE.Vector3(0,0,1), rotateAngle);
				spotlight.translateY(2.5 * 20);
				spotlight.rotateX( rotateAngle / 9.3 );
				sunSphere.translateY(2.5 * 20);
				sunSphere.rotateX( rotateAngle / 9.3 );
				// gravitacija

				MovingCube.position.y += (hitrost - 20)/ 2;


			// move forwards/backwards/left/right
				if ( keyboard.pressed("W") && hitrost <= 20 ){
					hitrost += 2;
				}

				if ( keyboard.pressed("S") && hitrost > 0 ){
					hitrost -= 2;
				}
				MovingCube.translateZ( hitrost );
				// rotate left/right/up/down
				var rotation_matrix = new THREE.Matrix4().identity();
				if ( keyboard.pressed("A") )
					MovingCube.rotateOnAxis( new THREE.Vector3(0,1,0), rotateAngle);
				if ( keyboard.pressed("D") )
					MovingCube.rotateOnAxis( new THREE.Vector3(0,1,0), -rotateAngle);
				if ( keyboard.pressed("right") )
					MovingCube.rotateOnAxis( new THREE.Vector3(0,0,1), rotateAngle);
				if ( keyboard.pressed("left") )
					MovingCube.rotateOnAxis( new THREE.Vector3(0,0,1), -rotateAngle);
				if ( keyboard.pressed("down") )
					MovingCube.rotateOnAxis( new THREE.Vector3(1,0,0), rotateAngle);
				if ( keyboard.pressed("up") )
					MovingCube.rotateOnAxis( new THREE.Vector3(1,0,0), -rotateAngle);

				if ( keyboard.pressed("Z") )
				{
					MovingCube.position.set(1000,2000,3000);
					MovingCube.rotation.set(0,0,0);
				}

				var relativeCameraOffset = new THREE.Vector3(0,850,-3000);

				var cameraOffset = relativeCameraOffset.applyMatrix4( MovingCube.matrixWorld );

				camera.position.x = cameraOffset.x;
				camera.position.y = cameraOffset.y;
				camera.position.z = cameraOffset.z;
				camera.lookAt( MovingCube.position );

				//camera.updateMatrix();
				//camera.updateProjectionMatrix();

				stats.update();
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function generateHeight( width, height ) {

				var size = width * height, data = new Uint8Array( size ),
				perlin = new ImprovedNoise(), quality = 1, z = Math.random() * 100;

				for ( var j = 0; j < 4; j ++ ) {

					for ( var i = 0; i < size; i ++ ) {

						var x = i % width, y = ~~ ( i / width );
						data[ i ] += Math.abs( perlin.noise( x / quality, y / quality, z ) * quality * 1.75 );

					}

					quality *= 5;

				}

				return data;

			}

			function generateTexture( data, width, height ) {

				var canvas, canvasScaled, context, image, imageData,
				level, diff, vector3, sun, shade;

				vector3 = new THREE.Vector3( 0, 0, 0 );

				sun = new THREE.Vector3( 1, 1, 1 );
				sun.normalize();

				canvas = document.createElement( 'canvas' );
				canvas.width = width;
				canvas.height = height;

				context = canvas.getContext( '2d' );
				context.fillStyle = '#000';
				context.fillRect( 0, 0, width, height );

				image = context.getImageData( 0, 0, canvas.width, canvas.height );
				imageData = image.data;

				for ( var i = 0, j = 0, l = imageData.length; i < l; i += 4, j ++ ) {

					vector3.x = data[ j - 2 ] - data[ j + 2 ];
					vector3.y = 2;
					vector3.z = data[ j - width * 2 ] - data[ j + width * 2 ];
					vector3.normalize();

					shade = vector3.dot( sun );

					imageData[ i ] = ( 96 + shade * 128 ) * ( 0.5 + data[ j ] * 0.007 );
					imageData[ i + 1 ] = ( 32 + shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );
					imageData[ i + 2 ] = ( shade * 96 ) * ( 0.5 + data[ j ] * 0.007 );
				}

				context.putImageData( image, 0, 0 );

				// Scaled 4x

				canvasScaled = document.createElement( 'canvas' );
				canvasScaled.width = width * 4;
				canvasScaled.height = height * 4;

				context = canvasScaled.getContext( '2d' );
				context.scale( 4, 4 );
				context.drawImage( canvas, 0, 0 );

				image = context.getImageData( 0, 0, canvasScaled.width, canvasScaled.height );
				imageData = image.data;

				for ( var i = 0, l = imageData.length; i < l; i += 4 ) {

					var v = ~~ ( Math.random() * 5 );

					imageData[ i ] += v;
					imageData[ i + 1 ] += v;
					imageData[ i + 2 ] += v;

				}

				context.putImageData( image, 0, 0 );

				return canvasScaled;

			}

			//

			function animate() {

				requestAnimationFrame( animate );

				render();
				update();

			}

			function render() {

				renderer.render( scene, camera );

			}


		</script>

	</body>
</html>
